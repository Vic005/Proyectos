import React, { useState, useEffect, useCallback, createContext, useContext } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { 
    getFirestore, 
    collection, 
    onSnapshot, 
    addDoc, 
    updateDoc, 
    deleteDoc, 
    doc, 
    setLogLevel, 
    query,
    Timestamp,
    orderBy // Usaremos ordenación en el cliente para evitar errores de índice en Firestore.
} from 'firebase/firestore';
// CORRECCIÓN: Se añadió Square a la lista de importaciones de lucide-react.
import { PencilIcon, TrashIcon, CheckCircleIcon, PlusIcon, Loader2, List, Clock, User, XCircle, Square } from 'lucide-react';

// --- Configuración Global y Contexto ---

// Asegura que las variables globales del entorno Canvas estén disponibles
const appId = typeof __app_id !== 'undefined' ? __app_id : 'project-manager-default';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// Configuración de Log de Firebase para depuración
setLogLevel('Debug');

// Crear un Contexto para el estado de Firebase y el usuario
const FirebaseContext = createContext({
    db: null,
    auth: null,
    userId: null,
    isAuthReady: false,
    error: null,
});

// Hook para inicializar Firebase y manejar la autenticación
const useFirebaseInit = () => {
    const [db, setDb] = useState(null);
    const [auth, setAuth] = useState(null);
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false);
    const [error, setError] = useState(null);

    useEffect(() => {
        if (!firebaseConfig) {
            setError("Error: firebaseConfig no está disponible.");
            return;
        }

        try {
            const app = initializeApp(firebaseConfig);
            const firestore = getFirestore(app);
            const authInstance = getAuth(app);
            
            setDb(firestore);
            setAuth(authInstance);

            // 1. Manejar la autenticación (Token personalizado o Anónimo)
            const handleAuth = async () => {
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(authInstance, initialAuthToken);
                    } else {
                        await signInAnonymously(authInstance);
                    }
                } catch (e) {
                    console.error("Error durante la autenticación:", e);
                    setError("Fallo en la autenticación. Revisa la consola para más detalles.");
                }
            };
            
            // 2. Escuchar cambios de estado de autenticación
            const unsubscribe = onAuthStateChanged(authInstance, (user) => {
                if (user) {
                    setUserId(user.uid);
                    setIsAuthReady(true);
                    console.log(`Usuario autenticado: ${user.uid}`);
                } else if (!initialAuthToken) {
                    // Si no hay token inicial y el usuario se desloguea, intentamos anónimo
                    handleAuth(); 
                } else {
                    // Si hay token inicial pero falla el auth, el error ya se maneja
                    setUserId(null);
                    setIsAuthReady(true); // Consideramos listo el intento fallido
                }
            });

            // Si el token ya está disponible, iniciamos el proceso
            handleAuth();

            return () => unsubscribe();

        } catch (e) {
            console.error("Error al inicializar Firebase:", e);
            setError(e.message);
        }
    }, [initialAuthToken]);

    return { db, auth, userId, isAuthReady, error };
};

// --- Componente de Carga/Error/Contexto ---

const LoadingState = ({ error, userId }) => {
    return (
        <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-50">
            <div className="p-8 bg-white rounded-xl shadow-lg w-full max-w-md text-center">
                {error ? (
                    <>
                        <XCircle className="w-10 h-10 text-red-500 mx-auto mb-4" />
                        <h2 className="text-xl font-bold text-red-600 mb-2">Error de Configuración</h2>
                        <p className="text-gray-600">No se pudo iniciar la aplicación de gestión de proyectos.</p>
                        <p className="text-sm text-red-500 mt-2 break-all">{error}</p>
                    </>
                ) : (
                    <>
                        <Loader2 className="w-8 h-8 text-indigo-500 mx-auto mb-4 animate-spin" />
                        <h2 className="text-xl font-bold text-indigo-600">Cargando Tareas...</h2>
                        {userId && (
                            <p className="text-xs text-gray-500 mt-2 break-all">
                                ID de Usuario: {userId}
                            </p>
                        )}
                    </>
                )}
            </div>
        </div>
    );
};

const FirebaseProvider = ({ children }) => {
    const { db, auth, userId, isAuthReady, error } = useFirebaseInit();

    if (error || !isAuthReady || !userId || !db || !auth) {
        return <LoadingState error={error} userId={userId} />;
    }

    return (
        <FirebaseContext.Provider value={{ db, auth, userId, isAuthReady, error }}>
            {children}
        </FirebaseContext.Provider>
    );
};

// --- Lógica del Gestor de Tareas ---

// Función utilitaria para obtener la referencia de la colección
const getCollectionRef = (db, userId) => {
    // Path: /artifacts/{appId}/users/{userId}/tasks
    return collection(db, 'artifacts', appId, 'users', userId, 'tasks');
};

const useTasks = () => {
    const { db, userId } = useContext(FirebaseContext);
    const [tasks, setTasks] = useState([]);
    const [isLoading, setIsLoading] = useState(true);

    // 1. READ: Suscripción en tiempo real a las tareas
    useEffect(() => {
        if (!db || !userId) return;

        const tasksRef = getCollectionRef(db, userId);
        // Creamos un query simple. Evitamos `orderBy` en la consulta
        // para prevenir errores de índices que son difíciles de manejar en este entorno.
        // Ordenaremos los datos después de recibirlos.
        const q = tasksRef;

        const unsubscribe = onSnapshot(q, (snapshot) => {
            const fetchedTasks = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data(),
                // Convertir Timestamp de Firebase a objeto Date de JS
                createdAt: doc.data().createdAt?.toDate() || new Date()
            }));

            // Ordenación local: primero incompletas, luego por fecha de creación (más nuevas primero)
            const sortedTasks = fetchedTasks.sort((a, b) => {
                if (a.completed === b.completed) {
                    return b.createdAt - a.createdAt; // Más reciente primero
                }
                return a.completed ? 1 : -1; // Incompletas primero (false < true)
            });

            setTasks(sortedTasks);
            setIsLoading(false);
        }, (error) => {
            console.error("Error al obtener las tareas en tiempo real:", error);
            setIsLoading(false);
            // Mostrar un error de red o permisos
        });

        return () => unsubscribe();
    }, [db, userId]);

    // 2. CREATE: Agregar una nueva tarea
    const addTask = useCallback(async (description) => {
        if (!db || !userId || !description.trim()) return;
        try {
            await addDoc(getCollectionRef(db, userId), {
                description: description.trim(),
                completed: false,
                createdAt: Timestamp.now(),
            });
        } catch (e) {
            console.error("Error al añadir la tarea:", e);
        }
    }, [db, userId]);

    // 3. UPDATE: Cambiar el estado o descripción de una tarea
    const updateTask = useCallback(async (taskId, data) => {
        if (!db || !userId) return;
        try {
            const taskDocRef = doc(getCollectionRef(db, userId), taskId);
            await updateDoc(taskDocRef, data);
        } catch (e) {
            console.error("Error al actualizar la tarea:", e);
        }
    }, [db, userId]);

    // 4. DELETE: Eliminar una tarea
    const deleteTask = useCallback(async (taskId) => {
        if (!db || !userId) return;
        try {
            const taskDocRef = doc(getCollectionRef(db, userId), taskId);
            await deleteDoc(taskDocRef);
        } catch (e) {
            console.error("Error al eliminar la tarea:", e);
        }
    }, [db, userId]);

    return { tasks, isLoading, addTask, updateTask, deleteTask };
};

// --- Componentes de UI ---

const TaskInput = ({ addTask, isLoading }) => {
    const [description, setDescription] = useState('');
    const [isAdding, setIsAdding] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!description.trim() || isAdding) return;
        
        setIsAdding(true);
        await addTask(description);
        setDescription('');
        setIsAdding(false);
    };

    return (
        <form onSubmit={handleSubmit} className="flex gap-2 p-4 bg-white rounded-xl shadow-inner">
            <input
                type="text"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="Escribe una nueva tarea..."
                className="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-150"
                disabled={isAdding || isLoading}
                required
            />
            <button
                type="submit"
                className={`flex items-center justify-center p-3 text-white rounded-lg transition duration-300 ${
                    isAdding || isLoading ? 'bg-indigo-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-700 shadow-md'
                }`}
                disabled={isAdding || isLoading || !description.trim()}
            >
                {isAdding ? <Loader2 className="w-5 h-5 animate-spin" /> : <PlusIcon className="w-5 h-5" />}
            </button>
        </form>
    );
};

const TaskItem = ({ task, updateTask, deleteTask }) => {
    const [isEditing, setIsEditing] = useState(false);
    const [newDescription, setNewDescription] = useState(task.description);

    const toggleCompleted = () => {
        updateTask(task.id, { completed: !task.completed });
    };

    const handleEditSave = () => {
        if (newDescription.trim() !== task.description) {
            updateTask(task.id, { description: newDescription.trim() });
        }
        setIsEditing(false);
    };

    const formatTime = (date) => {
        if (!date) return 'Desconocida';
        // Formato simple para la hora de creación
        return new Intl.DateTimeFormat('es-ES', { 
            hour: '2-digit', 
            minute: '2-digit', 
            day: '2-digit',
            month: '2-digit'
        }).format(date);
    };

    return (
        <div className={`flex items-center p-4 rounded-xl shadow-sm transition duration-300 transform ${
            task.completed ? 'bg-green-50 border-l-4 border-green-500 opacity-70' : 'bg-white hover:shadow-md'
        }`}>
            {/* Checkbox */}
            <button 
                onClick={toggleCompleted}
                className="p-1 rounded-full mr-3 text-gray-400 hover:text-green-500 transition duration-150"
                aria-label={task.completed ? "Marcar como incompleta" : "Marcar como completa"}
            >
                <CheckCircleIcon 
                    className={`w-6 h-6 ${task.completed ? 'text-green-500 fill-current' : 'text-gray-300'}`}
                />
            </button>

            {/* Content */}
            <div className="flex-grow min-w-0">
                {isEditing ? (
                    <input
                        type="text"
                        value={newDescription}
                        onChange={(e) => setNewDescription(e.target.value)}
                        onBlur={handleEditSave}
                        onKeyDown={(e) => { if (e.key === 'Enter') handleEditSave(); }}
                        className="w-full p-1 border-b border-indigo-400 focus:outline-none"
                        autoFocus
                    />
                ) : (
                    <p 
                        className={`text-lg font-medium truncate ${task.completed ? 'line-through text-gray-500' : 'text-gray-800'}`}
                        onDoubleClick={() => setIsEditing(true)}
                    >
                        {task.description}
                    </p>
                )}
                <div className="flex items-center text-xs text-gray-400 mt-1">
                    <Clock className="w-3 h-3 mr-1" />
                    <span>Creado: {formatTime(task.createdAt)}</span>
                </div>
            </div>

            {/* Actions */}
            <div className="flex items-center space-x-2 ml-4">
                <button
                    onClick={() => setIsEditing(!isEditing)}
                    className="p-2 text-indigo-500 hover:bg-indigo-100 rounded-full transition duration-150"
                    aria-label="Editar tarea"
                >
                    <PencilIcon className="w-5 h-5" />
                </button>
                <button
                    onClick={() => deleteTask(task.id)}
                    className="p-2 text-red-500 hover:bg-red-100 rounded-full transition duration-150"
                    aria-label="Eliminar tarea"
                >
                    <TrashIcon className="w-5 h-5" />
                </button>
            </div>
        </div>
    );
};

// --- Componente Principal ---

const TaskManagerApp = () => {
    const { tasks, isLoading, addTask, updateTask, deleteTask } = useTasks();
    const { userId } = useContext(FirebaseContext);

    const completedTasks = tasks.filter(t => t.completed).length;
    const totalTasks = tasks.length;
    const pendingTasks = totalTasks - completedTasks;

    return (
        <div className="min-h-screen bg-gray-100 p-4 sm:p-8 font-sans">
            <div className="max-w-3xl mx-auto">
                {/* Header */}
                <header className="mb-6">
                    <h1 className="text-4xl font-extrabold text-gray-900 flex items-center mb-2">
                        <List className="w-8 h-8 mr-3 text-indigo-600" />
                        Gestor de Tareas PRO
                    </h1>
                    <p className="text-sm text-gray-500 flex items-center break-all">
                        <User className="w-4 h-4 mr-1" />
                        ID de Usuario (para compartir): <span className="font-mono text-xs ml-1 bg-gray-200 px-1 py-0.5 rounded">{userId}</span>
                    </p>
                </header>

                {/* Resumen de Tareas */}
                <div className="grid grid-cols-2 gap-4 mb-6">
                    <div className="bg-white p-4 rounded-xl shadow flex items-center justify-between">
                        <div>
                            <p className="text-sm text-gray-500">Pendientes</p>
                            <p className="text-2xl font-bold text-red-500">{pendingTasks}</p>
                        </div>
                        <Square className="w-6 h-6 text-red-400" />
                    </div>
                    <div className="bg-white p-4 rounded-xl shadow flex items-center justify-between">
                        <div>
                            <p className="text-sm text-gray-500">Completadas</p>
                            <p className="text-2xl font-bold text-green-600">{completedTasks}</p>
                        </div>
                        <CheckCircleIcon className="w-6 h-6 text-green-400" />
                    </div>
                </div>

                {/* Input de Tarea */}
                <TaskInput addTask={addTask} isLoading={isLoading} />

                {/* Lista de Tareas */}
                <main className="mt-6 space-y-3">
                    {isLoading ? (
                        <div className="text-center p-8 bg-white rounded-xl shadow-md">
                            <Loader2 className="w-6 h-6 text-indigo-500 mx-auto mb-3 animate-spin" />
                            <p className="text-gray-600">Sincronizando con Firebase...</p>
                        </div>
                    ) : (
                        tasks.length > 0 ? (
                            tasks.map(task => (
                                <TaskItem
                                    key={task.id}
                                    task={task}
                                    updateTask={updateTask}
                                    deleteTask={deleteTask}
                                />
                            ))
                        ) : (
                            <div className="text-center p-8 bg-white rounded-xl shadow-md">
                                <List className="w-8 h-8 text-gray-400 mx-auto mb-3" />
                                <p className="text-gray-600 font-semibold">¡Todo listo!</p>
                                <p className="text-sm text-gray-500">Añade tu primera tarea arriba para empezar.</p>
                            </div>
                        )
                    )}
                </main>
            </div>
        </div>
    );
};

// Componente principal que envuelve todo en el contexto de Firebase
const App = () => (
    <FirebaseProvider>
        <TaskManagerApp />
    </FirebaseProvider>
);

export default App;
